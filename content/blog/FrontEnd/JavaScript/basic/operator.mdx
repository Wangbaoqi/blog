---
title: JS 运算符
date: 2021-02-21 10:28:48
cover: https://cdn.jsdelivr.net/gh/Wangbaoqi/blogImgs@master/nateImgs/JavaScript/bg/operator.png
tags: 
  - javascript
categories: 前端
---

> EMCA-262 描述了一组可以用于数据值的操作符。包括 **数学操作符、位运算符、关系运算符、相等运算符**。

## 一元操作符

只操作一个值的运算符的为一元运算符。包括了**递增/递减运算**符和**一元加和减**

**递增/递减运算符**

包括了自增`++`和自减`--` ，可以放在数字类型值的前后，两者之间还是有区别的

```javascript
let num1 = 2;
let num2 = 10;
let num3 = ++num1; // 3
let num4 = ++num1 + num2; // 14
```

上述`num1`进行递增运算之后，自身就会加`1`，跟 `num1 + 1` 一样。除了放在变量之前，也可以放在变量之后。

```javascript
let num1 = 2;
let num2 = 10;
let num3 = num1++; // 3
let num4 = num1++ + num2; // 13
console.log(num1); // 4
```

很明显，可以看到两者之间的区别。

如果只有自身进行递增、递减运算时，没有区别，跟 `num1 + 1` 或者 `num1 - 1` 结果一样。

如果跟其他运算符结合在一起，就有了明显区别。前递增首先会递增自身，然后再跟其他运算符运算。而后递增会先跟其他运算符先运算，然后再自身递增。

递减（前后）跟递增的处理方式是一致的。

### 一元加和减

一元加`+` 和 一元减 `-` 也时很常见的。

如果 `+` 放在number类型值的前面，没有什么区别和自身。

如果 `+` 放在非number类型值的前面，就会进行类型转换，调用`Number()`转型函数，类型转换请看[「JS 基础 - 数据类型」](data-type.md#lei-xing-zhuan-huan)。

同理，一元 `-` 跟 一元加执行一样的规则，唯一不同的是放在数字前面，就会将该值转换为负值。

## 位操作符

位操作符是针对数值的底层运算，也就是操作内存中数值的比特位。

ECMAScript 12 中的所有数值都以** IEEE 754** 64 位格式存储，但位操作并不直接应用到 64 位表示，而是先把值转换为32 位整数，再进行位操作，之后再把结果转换为 64 位。

对开发者而言，就好像只有 32 位整数一样，因 为 64 位整数存储格式是不可见的。

**有符号整数使用 32 位的前 31 位表示整数值**。第 32 位表示数值的符号，如 0 表示正，1 表示负。这 一位称为**符号位(sign bit)**，它的值决定了数值其余部分的格式。

正值以真正的二进制格式存储，即 31 位中的每一位都代表 2 的幂。第一位(称为第 0 位)表示 2^0，第二位表示 2^1，依此类推。如果一个位是空的，则以 0 填充，相当于忽略不计。

```javascript
// 数字10的二进制表示 这里空格是为了方便看
let numBinary = 0000 0000 0000 0000 0000 0000 0000 1010
// 用toString计算二进制
(10).toString(2); // 1010
```

负值以一种二补数（补码）的二进制编码存储，如果要计算负数的二进制，要进行三个步骤：

* 确定数值的绝对值二进制 （-10，绝对值 就是 10）
* 计算数值的补数（**反码**），也就是`1`转换为`0`，`0`转换为`1` 
* 给补数加1

这里涉及到了补码和反码，这里对比一下跟源码的区别以及之间是怎么转换的。

在这之前，补充一下二进制之间的**加减乘除**运算规则；

**加运算：**`0+0=0`，`0+1=1`，`1+0=1`，`1+1=10`

```bash
进位      11  
原码     0011
原码     1001
分隔    -----
结果     1100 
```

**减运算：**`1-1=0`，`1-0=1`，`0-0=0`，`0－1 = -1`

```bash
进位    1                   11111
原码     0011              01000000
原码     1001              00001010
分隔    -----            ----------
结果    11100              00110110
```

**乘法运算：**`0×0=0`，`0×1=0`，`1×0=0`，`1×1=1`

```bash
进位        
原码     0011
原码     1001
分隔    -----
结果     0001 
```

**除法运算**：`0÷1=0`，`1÷1=1`

```bash
结果      00111 
分隔      -----      
原码   11|10101   
原码     - 11       
分隔      ----- 
余数       100
原码      - 11 
分隔      ----- 
余数         11
原码       - 11 
分隔      ----- 
余数          0
```

了解了二进制运算之后，接着往下看

```bash
数值 0 --> 原码 0000 
数值 -0 --> 原码 1000
数值运算 0 + (-0) = -0 --> 原码 0000 + 1000 = 1000

上面对0和-0进行十进制和二进制运算 结果都是0 二进制是带符号的
再看数值1和-1之间的运算

数值 1 --> 原码 0001
数值 -1 --> 原码 1001
数值运算 -1 + 1 = 0 --> 原码 1001 + 0001 = 1010 = -2（十进制）
```

可以看到，`-1`和`1`二进制位的和运算不对。因此提出了**反码**的概念。

**如果是正数，其反码不变；如果是负数**，**符号位不变，其他位取反**。然后再来看上述结果。

```bash
数值 1 --> 原码 0001
数值 -1 --> 原码 1001
数值运算 -1 + 1 = 0 --> 反码 1110 + 0001 = 1111 = -0（十进制）
```

可以看到，结果为带符号位的值-0，但是`-1 + 1 = 0` 不应该带符号位。因此，又提出了**补码**的概念。

如果是正数，则补码不变，如果是负数，则补码在其反码的基础上加 `1`

继续看上述例子

```bash
数值 1 --> 原码 0001
数值 -1 --> 原码 1001
数值运算 -1 + 1 = 0 --> 补码 1111 + 0001 = 0000 = 0（十进制）
```

可以看到，此时结果没有带符号位，结果是正确的。了解了上述基础之后，下面来看下位运算有哪几种，每种是怎么运算的。

### 按位非操作符

按位非操作符用波浪符(\~)表示，它的作用是返回**数值的一补数，也就是数值的反码**。按位非是 ECMAScript 中为数 不多的几个二进制数学操作符之一

```javascript
let num = 10; // 原码 0000 0000 0000 0000 0000 0000 0000 1010
let num1 = ~num; // 反码 1111 1111 1111 1111 1111 1111 1111 0101
console.log(num1); // -11
```

可以看到，按位非的结果是对**数值取反减一**。

### 按位与操作符

按位与操作符用和号(&)表示，有两个操作数。本质上，按位与就是将两个数的每一个位对齐， 然后基于真值表中的规则，对每一位执行相应的与操作

| 第一个数值位 | 第二个数值位 | 结果 |
| ------ | ------ | -- |
| 1      | 1      | 1  |
| 1      | 0      | 0  |
| 0      | 1      | 0  |
| 0      | 0      | 0  |

```javascript
let num = 2; // 原码 0000 0000 0000 0000 0000 0000 0000 0010
let num1 = 3; // 原码 0000 0000 0000 0000 0000 0000 0000 0011
let num2 = 2 & 3; // 原码 0000 0000 0000 0000 0000 0000 0000 0010
console.log(num2); // 2
```

### 按位或操作符

按位或操作符用管道符(|)表示，同样有两个操作数。按位或遵循如下真值表

| 第一个数值位 | 第二个数值位 | 结果 |
| ------ | ------ | -- |
| 1      | 1      | 1  |
| 1      | 0      | 1  |
| 0      | 1      | 1  |
| 0      | 0      | 0  |

```javascript
let num = 2;  // 原码 0000 0000 0000 0000 0000 0000 0000 0010
let num1 = 3; // 原码 0000 0000 0000 0000 0000 0000 0000 0011
let num2 = 2 | 3; // 原码 0000 0000 0000 0000 0000 0000 0000 0011
console.log(num2); // 3
```

### 按位异或操作符

按位异或用脱字符(^)表示，同样有两个操作数。下面是按位异或的真值表:

| 第一个数值位 | 第二个数值位 | 结果 |
| ------ | ------ | -- |
| 1      | 1      | 0  |
| 1      | 0      | 1  |
| 0      | 1      | 1  |
| 0      | 0      | 0  |

```javascript
let num = 2;  // 原码 0000 0000 0000 0000 0000 0000 0000 0010
let num1 = 3; // 原码 0000 0000 0000 0000 0000 0000 0000 0011
let num2 = 2 | 3; // 原码 0000 0000 0000 0000 0000 0000 0000 0001
console.log(num2); // 1
```

### 左移操作符

左移操作符用两个小于号(<<)表示，会按照指定的位数将**数值的所有位**向左移动。空出来的位用0来填充。

```javascript
let num = 2; // 原码 0000 0000 0000 0000 0000 0000 0000 0010
let num1 = num << 3; // 原码 0000 0000 0000 0000 0000 0000 0001 0000
```

左移会保留他的操作数值的符号。

```javascript
let num = 2;
let num1 = -2;
console.log(num << 3); // 16
console.log(num2 << 3); // -16
```

### 有符号右移

有符号右移由两个大于号(>>)表示，会将数值的**所有 32 位都向右移**，**同时保留符号(正或负)**。 有符号右移实际上是左移的逆运算。

移位后就会出现空位。不过，右移后空位会出现在左侧，且在符号位之后。 ECMAScript 会用**符号位的值来填充这些空位**，以得到完整的数值。

```javascript
let num = 20; // 原码 0000 0000 0000 0000 0000 0000 0001 0100
let num1 = num >> 2; // 原码 0 00 0 0000 0000 0000 0000 0000 0000 0101
let num2 = -20;      // 原码 1111 1111 1111 1111 1111 1111 1110 1011 + 1
let num3 = num2 >> 2; // -5
console.log(num1); // 5
```

可以看到，正数和负数在有符号的结果是一致的，除了符号。

### 无符号右移

无符号右移用 3 个大于号表示(>>>)，会将数值的所有 32 位都向右移。对于正数，无符号右移与 有符号右移结果相同。

```javascript
let num = 20; // 原码 0000 0000 0000 0000 0000 0000 0001 0100
let num1 = num >> 2; // 原码 0 00 0 0000 0000 0000 0000 0000 0000 0101
let num2 = num >>> 2; // 原码 0 00 0 0000 0000 0000 0000 0000 0000 0101
console.log(num1); // 5
console.log(num2); // 5
```

无符号右移操作符将负数的二进制表示当成**正数的二进制**表示来处理，因为负数是其绝对值的二补数，所以右移之后结果变 得非常之大。

```javascript
let num = -20; // 原码 1111 1111 1111 1111 1111 1111 1110 1100
let num2 = num >>> 2; // 移动后的原码 00 1111 1111 1111 1111 1111 1111 1110 11
console.log(num2); // 1073741819
parseInt('00111111111111111111111111111011', 2) // 1073741819
```

可以看到在-20的原码基础向右移动了两位，然后将其移动后的原码当做是正数的二进制处理。


---
title: JS 性能相关篇
date: 2021-06-03 10:28:48
cover: https://cdn.jsdelivr.net/gh/Wangbaoqi/blogImgs@master/nateImgs/JavaScript/bg-api/performance.png
tags: 
  - JavaScript 实现
categories: JavaScript 实现
---

## 事件委托

事件委托常使用的场景是列表点击，将每一个元素的点击的事件委托到其父元素，其实现的原理是基于事件冒泡完成的

```javascript
/**
 * el 委托的元素
 * type 事件类型
 * selector 选择的元素
 * fn 回调函数
 **/

const bindEvent = (el, type, selector, fn) => { 
  if(fn == void 0) {
    fn = selector;
    selector = null;
  }
  
  el.addEventListener(type, (evt) => {
    const target = evt.target;
    // 事件委托
    if(selector && el.matches(selector)) {
      fn.call(target, evt)
    }
    // 普通监听事件
    if(!selector) {
     fn.call(target, evt)
    }
  })
}

```

## DOM树的操作

* 获取DOM树的节点个数
* 获取DOM树的最大深度
* 获取DOM树的最大子节点个数

```js
/**
 * 2.DOM 的体积过大会影响页面性能，假如你想在用户关闭页面时统计（计算并反馈给服务器）
 当前页面中元素节点的数量总和、元素节点的最大嵌套深度以及最大子元素个数，请用 JS 配合
 原生 DOM API 实现该需求（不用考虑陈旧浏览器以及在现代浏览器中的兼容性，可以使用任意
 浏览器的最新特性；不用考虑 shadow DOM）。比如在如下页面中运行后：
 */
<html>
  <head></head>
  <body>
    <section>
      <span>f</span>
      <span>o</span>
      <span>o</span>
    </section>
  </body>
</html>
// 会输出：
{
  totalElementsCount: 7,
  maxDOMTreeDepth: 4,
  maxChildrenCount: 3
}
```

### DOM树的节点总数

遍历DOM树的节点会使用`深度优先遍历`

```js
// DFS 递归实现
const computeDOMCount = (dom) => {
  let c = 0;
  const computer = dom => {
    c++
    if(dom.children) {
      [...dom.children].forEach(v => computer(v))
    }
  }
  computer(dom)
  return c
}

// DFS 迭代实现
const computeDOMCount = (dom) => {
  let stack = [dom]
  let c = 0;
  while(stack.length) {
    let nodes = stack.shift();
    c++
    [...nodes.children].forEach(v => stack.push(v))
  }
  return c
}
```

### DOM树的最大深度

```js
// DFS 递归实现
const computeDOMDepth = dom => {

  if(!dom.children.length) return 1;

  let levelMax = [...dom.children].map(v => computeDOMDepth(v))

  return 1 + Math.max(...levelMax)
}

// DFS 迭代实现
const computeDOMDepth = dom => {

  let stack = [dom];
  let depth = 0;
  while(stack.length) {
    depth++
    const count = stack.length;
    let s = 0;
    while(s < count) {
      s++
      const nodes = stack.shift();
      for(let item of nodes) {
        stack.push(item)
      }
    }
  }
}
```

### DOM树最大子元素个数

```js
// BFS 
const computeDOMMaxChildCount = dom => {
  let stack = [dom];
  let count = 0;

  while(stack.length) {
    let size = stack.length;
    let levels = [];
    let i = 0;
    count = Math.max(count, size)

    while(i < size) {
      i++;
      const nodes = stack.shift();
      for(const node of nodes) {
        levels.push(node)
      }
    }
    stack = levels
  }
  return count;
}
```

### 同时获取三者

```js

// BFS 层序遍历 获取所有的节点值
const computeDOM = dom => {

  let stack = [dom];

  let totalElementsCount = 0,
      maxDOMTreeDepth = stack.length || 0,
      maxChildrenCount = 0;
  
  let nextLevel = []

  while(stack.length || nextLevel.length) {

    if(!stack.length) {
      stack = nextLevel;
      maxDOMTreeDepth++;
      nextLevel = [];
      continue;
    }
    totalElementsCount++;
    const nodes = stack.shift();
    maxChildrenCount = Math.max(maxChildrenCount, nodes.children.length);
    nextLevel=[...nodes.children]
  }
}
```

## 节流防抖

节流和防抖在优化性能起着一定的作用。

### 防抖

防抖应用的场景是频繁操作，比如频繁点击按钮，需要调用接口时，一段时间内执行一次。

```js
const debounce = (fn, wait, im) => {
  let timer = null, cIm = im;

  return (...args) => {
    if(cIm) {
      fn.apply(this, args)
      cIm = false
    }
    timer && clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, args)
    },wait)
  }
}
```

### 节流

节流和防抖都是阻止频繁操作，不同的是`节流`是**每隔一段时间执行一次**，`防抖`是**一段时间内执行一次**

```js
const throttle = (fn, wait) => {
  let timer;
  return (...args) => {
    if(timer) return;
    timer = setTimeout(() => {
      fn.apply(this, args)
      timer = null
    }, wait)
  }
}

```

### Lodash 防抖节流

> 源码[入口](https://github.com/lodash/lodash/blob/master/debounce.js#L65)

**debounce**

```js
function debounce(fn, wait, options) {
  
  /* 初始化变量 */
  let lastArgs,   // 上次传递的参数
    lastThis,     // 上次调用时的this
    maxWait,      // 最大的等待时间
    result,       // 回调函数fn执行的返回值
    timerId,      // 定时器id 
    lastCallTime  // 上一次调用 debounce 的时间

  let lastInvokeTime = 0 // 上一次调用回调函数fn的时间
  let leading = false    // 延迟前执行
  let maxing = false     // 是否设置最大等待时间，用于 throttle
  let trailing = true    // 延迟后执行

  // root 是当前执行环境上下文
  const useRAF = (!wait && wait !== 0 && typeof root.requestAnimationFrame === 'function')

  if (typeof func !== 'function') {
    throw new TypeError('Expected a function')
  }
  wait = +wait || 0
  // 处理初始化变量
  if (isObject(options)) {
    leading = !!options.leading
    maxing = 'maxWait' in options
    maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait
    trailing = 'trailing' in options ? !!options.trailing : trailing
  }


  /* 定时器处理函数 */ 

  // 延迟前
  function leadingEdge(time) {}

  // 延迟后回调
  function trailingEdge(time) {}

  // 调用回调函数fn
  function invokeFunc(time) {}

  // 判断是否当前需要执行fn
  function shouldInvoke(time) {}




  // 计算需要等待的时间
  function remainingWait(time) {}

  // 定时器回调
  function timerExpired() {}

  // 开始定时器
  function startTimer(pendingFunc, wait) {}

  // 取消定时器
  function cancelTimer() {}



  /* 外部接口 */

  // 取消延迟
  function cancel() {}

  // 立即调用
  function flush() {}

  // 是否在定时器中
  function pending() {}


  /* 入口 */

  function debounced() {}


  debounced.cancel = cancel;
  debounced.flush = flush;
  debounced.pending = pending;

  return debounced
}
export {debounce}


```


## 图片懒加载

## Sleep/Delay 实现

## setTimeout实现setInterval




---
id: 287
title: 287. 寻找重复数
date: '2022-07-02'
level: easy
hot: 4
author:
  name: NateWang
  picture: 'https://media.wangbaoqi.tech/assets/authors/logo.png'
postShow: true
tags:
  - 二分法
  - 哈希
  - 排序
category: Algorithm
subCategory: everyDay
---

import Para from './mdx/component/para.js'

**LeetCode** [寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/)

> 给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。
> <Para>假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。</Para>
> <Para>你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。</Para>

**示例**

```
输入：nums = [1,3,4,2,2]
输出：2
示例 2：

输入：nums = [3,1,3,4,2]
输出：3

```

**提示**

1. `1 <= n <= 105`
2. `nums.length == n + 1`
3. `1 <= nums[i] <= n`

**nums 中 只有一个整数出现两次或多次 ，其余整数均只出现 一次**
 

**进阶**

如何证明 nums 中至少存在一个重复的数字?
你可以设计一个线性级时间复杂度 O(n) 的解决方案吗？


## 排序 + 双指针

如果不考虑更优的解法的话，可以使用最为直接的方式，比如**双重循环**，但是这种时间复杂度太高了，这里没必要使用。

其次，如果使用**O(n)**时间复杂度的话，可以联想到**双指针（快慢指针）+ 排序**来解决。


```ts
const findDuplicate = (nums: number[]): number => {

  nums.sort((a, b) => a - b);

  const n = nums.length;
  let f = 1, s = 0;
  
  while (f < n) {
    
    if (nums[f] == nums[s]) return nums[f];

    f++;
    s++;
  }
  return -1;
}
```

此方式从时间复杂度**O(logn + n)**来讲，并不是最优的，而且该解法违反了题意中的**不可改变原数组**的规定。


## 哈希表

